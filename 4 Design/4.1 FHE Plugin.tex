\section{Fully Homomorphic Encryption Library}
\label{sec:Fully Homomorphic Encryption Library}
This implementation adheres to the core design principle of modularity, remaining agnostic to the underlying C++ library. Instead of directly invoking methods within the plugin, the plugin uses the Bridge and Adapter structural design patterns inspired by the work of Alberto Ibarrondo and Alexander Viand \cite{Ibarrondo2021-Pyfhel}. The Bridge pattern decouples the high-level Dart API from the specific C++ implementation by defining an abstract interface. The Adapter pattern connects the Dart interface to the C++ implementation through a C-based intermediary, translating Dart requests into operations understood by the native library. This approach enables compatibility with multiple Fully Homomorphic Encryption (FHE) backends without modifying the Dart API.

The Fully Homomorphic Encryption Library provides a modular API that integrates Microsoft SEAL with the Flutter ecosystem. It offers a straightforward interface for developers, abstracting low-level complexities while delivering access to advanced encryption functionalities required for secure applications. The topology of this Dart plugin ensures a clear separation of responsibilities to promote maintainability and extensibility. Table \ref{table:class-structure} outlines the distinct roles of each component, including the high-level API, the adapter interface, and the concrete implementation.

\input{4 Design/4.1 Topology Table}

Each file plays a specific role in this architecture. The \textit{seal.dart} file provides the primary entry point for the end-user API, allowing developers to interact with the encryption library in Dart. The \textit{afhe.dart} file acts as the adapter, invoking lower-level C functions. The Afhe class exposes abstracted data types such as Keys, Ciphertext, and Plaintext objects. The \textit{fhe.cpp} file defines the C interface. It exposes the inherited methods from \textit{afhe.h} and references the memory address of the underlying C++ object. Depending on the reference, the corresponding concrete implementation will be invoked. For example, \textit{aseal.cpp} manages Microsoft SEAL objects.

The Foreign Function Interface (FFI) is this plugin's core dependency; It enables Dart to interact with the pre-compiled C binary. For each target platform, the dynamically linked library must be accessible on the local file system. This plugin exposes methods to cast native C data types into Dart objects and vice versa. Our implementation creates Dart objects that mirror their corresponding underlying C++ class. For example, in Microsoft SEAL, a Ciphertext can be saved or loaded. We expose \textit{save\_ciphertext} and \textit{load\_ciphertext} in the C interface. In Dart, we create a Ciphertext class that contains both \textit{save} and \textit{load}, referencing the memory address of the underlying abstract Ciphertext object. This implementation pattern is consistent and transparent for security researchers familiar with the underlying C++ API. For new developers, our implementation mirrors the structure of Microsoft SEAL, providing a clear and familiar interface.

In order to prevent breaking changes, unit tests ensure that the functional behavior of the library remains consistent and reliable throughout the development and release. Unit tests serve as a safety net. They ensure that existing features function as expected when new changes occur. This process reduces the risks of regressions. For SEAL, the authors developed a set of examples that walk the user through their APIs. As a part of the unit tests, we re-implemented these examples with our interface to increase our confidence that our implementation did not introduce any new or unexpected behaviors. For automation, GitHub Actions compiles and executes unit tests using GoogleTest \cite{GoogleTest} with CMake. In total, There are 78 unit tests: 35 in C and 43 in Dart.

In order to distribute this plugin to Linux and multiple Android flavors, GitHub Actions employs Conan \cite{Conan}. Conan automates the management of dependencies and packaging, specifically addressing the versioning of Microsoft SEAL and other backend libraries. For Linux, Conan streamlines the building and packaging process by automatically resolving dependencies tailored to various distributions (e.g., Ubuntu, Fedora, and CentOS) while ensuring compatibility with different versions of Microsoft SEAL and system architectures (e.g., x86, ARM). Similarly, Conan simplifies cross-compilation for Android by allowing developers to specify configurations for various architectures and API levels, ensuring that the plugin can be compiled for the supported CPU architectures x86\_64, ARMv8, and ARMv7. The compiled binaries are all hosted on all platforms and are available for download for each release of the Dart plugin. When developers add the plugin to their dependencies, the binaries are pulled down from GitHub and stored within their local, versioned dependency cache. This automated approach enhances the consistency and reliability of the plugin across different environments, facilitating smoother deployment and easier updates for users.