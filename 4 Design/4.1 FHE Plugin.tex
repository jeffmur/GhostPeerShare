\section{Fully Homomorphic Encryption Library}

The topology of this Dart plugin is designed to create a clear separation of responsibilities among its components, as shown in Table \ref{table:class-structure}. It starts with the Dart Seal class, which serves as the main entry point for users. This class is responsible for creating and managing the underlying C objects that perform the core tasks of Fully Homomorphic Encryption (FHE). Next is the Dart adapter layer, Afhe. This layer defines a set of methods and attributes that allow users to create, modify, and delete C objects. Afhe acts as a middleman, translating high-level Dart commands into lower-level C function calls, so users donâ€™t need to deal with the complexities of the underlying implementation. The Foreign Function Interface (FFI) is essential in this architecture, as it routes method calls from Dart to the C interface layer, known as FHE. The FHE layer provides a C interface that gives access to the underlying C++ classes, making their functions available in a way that works with C-based languages and other systems. The FHE layer interacts with the C++ classes by wrapping their methods and properties in C functions, an approach borrowed from the work of Alberto Ibarrondo and Alexander Viand [2] in 2021. By using references to objects in memory, this layer can call C++ methods directly, which helps maintain performance while ensuring memory safety. A significant benefit of this design is that the FHE layer uses pointer references to avoid unnecessary data copying. This allows direct manipulation of memory objects created by the C++ classes, providing quick and efficient access to FHE functions from environments where direct C++ interaction is not possible. Additionally, this design simplifies memory management for the user, making it easier to work with. Finally, the interface layer manages the creation, updating, and deletion of pointers in memory that correspond to allocated SEAL objects. This ensures that resources are used effectively, which is crucial for maintaining the performance and reliability of the encryption processes.

In order to inadvertently introduce breaking changes, unit tests ensure that functional behavior of the library remains consistent and reliable throughout the development and release. Unit tests act as a safety net, ensuring that existing features work as expected with new changes, reducing the risks of regressions. For SEAL, the authors developed a set of examples that walk the user through their APIs. As a part of the unit tests, we re-implemented these examples with our interface to increase our confidence that our implementation did not introduce any new or unexpected behaviors. For automation, Github Actions is used to compile and execute unit tests using GoogleTest [21] with CMake. In total, there are 78 unit tests, 35 in C and 43 in Dart.

In order to distribute this plugin to Linux and multiple flavors of Android, Github Actions employs the use of Conan [22]. Conan automates the management of dependencies and packaging, specifically addressing the versioning of Microsoft SEAL and other backend libraries. For Linux, it streamlines the building and packaging process by automatically resolving dependencies tailored to various distributions, such as Ubuntu, Fedora, and CentOS, while ensuring compatibility with different versions of Microsoft SEAL and system architectures (e.g., x86, ARM). Similarly, for Android, Conan simplifies cross-compilation by allowing developers to specify configurations for various architectures and API levels, ensuring that the plugin can be compiled for the supported CPU architectures x86\_64, ARMv8, and ARMv7. The compiled binaries are all platforms hosted and available for download for each release of the Dart plugin. When a developer adds the plugin to their dependencies, the binaries are pulled down from Github and stored within their local, versioned, dependency cache. This automated approach enhances the consistency and reliability of the plugin across different environments, facilitating smoother deployment and easier updates for users.

\input{4 Design/4.1 Topology Table}